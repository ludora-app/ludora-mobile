/**
 * Generated by orval v7.3.0 ðŸº
 * Do not edit manually.
 * Ludora API
 * API for the Ludora app
 * OpenAPI spec version: 0.0.1
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';
import type {
  AuthB2CGenerateAccessTokenFromCode200,
  AuthB2CGoogleCallback200,
  BadRequestResponseDto,
  ConflictResponseDto,
  CreateGoogleUserDto,
  CreateOrConnectGoogleResponseDto,
  ForgottenPasswordDto,
  GenerateAccessTokenFromCodeDto,
  LoginDto,
  LoginResponseDto,
  LogoutResponseDto,
  NotFoundResponseDto,
  RefreshTokenDto,
  RefreshTokenResponseDto,
  RegisterB2CWithFileDto,
  RegisterResponseDto,
  SuccessTypeDto,
  UnauthorizedResponseDto,
  VerifyEmailCodeDto,
  VerifyEmailResponseDto,
  VerifyMailDto,
  VerifyTokenResponseDto,
} from '../../model';
import { customInstance } from '../../../orval.instance';

/**
 * @summary Create a user account
 */
export const authB2CRegister = (registerB2CWithFileDto: RegisterB2CWithFileDto, signal?: AbortSignal) => {
  const formData = new FormData();
  formData.append('type', registerB2CWithFileDto.type);
  if (registerB2CWithFileDto.deviceUid !== undefined) {
    formData.append('deviceUid', registerB2CWithFileDto.deviceUid);
  }
  formData.append('email', registerB2CWithFileDto.email);
  formData.append('password', registerB2CWithFileDto.password);
  if (registerB2CWithFileDto.firstname !== undefined) {
    formData.append('firstname', registerB2CWithFileDto.firstname);
  }
  if (registerB2CWithFileDto.lastname !== undefined) {
    formData.append('lastname', registerB2CWithFileDto.lastname);
  }
  if (registerB2CWithFileDto.phone !== undefined) {
    formData.append('phone', registerB2CWithFileDto.phone);
  }
  if (registerB2CWithFileDto.bio !== undefined) {
    formData.append('bio', registerB2CWithFileDto.bio);
  }
  if (registerB2CWithFileDto.birthdate !== undefined) {
    formData.append('birthdate', registerB2CWithFileDto.birthdate);
  }
  if (registerB2CWithFileDto.sex !== undefined) {
    formData.append('sex', registerB2CWithFileDto.sex);
  }
  if (registerB2CWithFileDto.file !== undefined) {
    formData.append('file', registerB2CWithFileDto.file);
  }

  return customInstance<RegisterResponseDto>({
    url: `/auth-b2c/register`,
    method: 'POST',
    headers: { 'Content-Type': 'multipart/form-data' },
    data: formData,
    signal,
  });
};

export const getAuthB2CRegisterMutationOptions = <
  TError = BadRequestResponseDto | ConflictResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authB2CRegister>>,
    TError,
    { data: RegisterB2CWithFileDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authB2CRegister>>,
  TError,
  { data: RegisterB2CWithFileDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authB2CRegister>>,
    { data: RegisterB2CWithFileDto }
  > = props => {
    const { data } = props ?? {};

    return authB2CRegister(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthB2CRegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof authB2CRegister>>
>;
export type AuthB2CRegisterMutationBody = RegisterB2CWithFileDto;
export type AuthB2CRegisterMutationError = BadRequestResponseDto | ConflictResponseDto;

/**
 * @summary Create a user account
 */
export const useAuthB2CRegister = <
  TError = BadRequestResponseDto | ConflictResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authB2CRegister>>,
    TError,
    { data: RegisterB2CWithFileDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authB2CRegister>>,
  TError,
  { data: RegisterB2CWithFileDto },
  TContext
> => {
  const mutationOptions = getAuthB2CRegisterMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Creates or connects a user with a Google account
 */
export const authB2CCreateOrConnectGoogleUser = (
  createGoogleUserDto: CreateGoogleUserDto,
  signal?: AbortSignal,
) => {
  return customInstance<CreateOrConnectGoogleResponseDto>({
    url: `/auth-b2c/google-login`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createGoogleUserDto,
    signal,
  });
};

export const getAuthB2CCreateOrConnectGoogleUserMutationOptions = <
  TError = BadRequestResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authB2CCreateOrConnectGoogleUser>>,
    TError,
    { data: CreateGoogleUserDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authB2CCreateOrConnectGoogleUser>>,
  TError,
  { data: CreateGoogleUserDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authB2CCreateOrConnectGoogleUser>>,
    { data: CreateGoogleUserDto }
  > = props => {
    const { data } = props ?? {};

    return authB2CCreateOrConnectGoogleUser(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthB2CCreateOrConnectGoogleUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof authB2CCreateOrConnectGoogleUser>>
>;
export type AuthB2CCreateOrConnectGoogleUserMutationBody = CreateGoogleUserDto;
export type AuthB2CCreateOrConnectGoogleUserMutationError = BadRequestResponseDto;

/**
 * @summary Creates or connects a user with a Google account
 */
export const useAuthB2CCreateOrConnectGoogleUser = <
  TError = BadRequestResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authB2CCreateOrConnectGoogleUser>>,
    TError,
    { data: CreateGoogleUserDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authB2CCreateOrConnectGoogleUser>>,
  TError,
  { data: CreateGoogleUserDto },
  TContext
> => {
  const mutationOptions = getAuthB2CCreateOrConnectGoogleUserMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Allow the user to login
 */
export const authB2CLogin = (loginDto: LoginDto, signal?: AbortSignal) => {
  return customInstance<LoginResponseDto>({
    url: `/auth-b2c/login`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: loginDto,
    signal,
  });
};

export const getAuthB2CLoginMutationOptions = <TError = BadRequestResponseDto, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authB2CLogin>>,
    TError,
    { data: LoginDto },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof authB2CLogin>>, TError, { data: LoginDto }, TContext> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authB2CLogin>>,
    { data: LoginDto }
  > = props => {
    const { data } = props ?? {};

    return authB2CLogin(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthB2CLoginMutationResult = NonNullable<Awaited<ReturnType<typeof authB2CLogin>>>;
export type AuthB2CLoginMutationBody = LoginDto;
export type AuthB2CLoginMutationError = BadRequestResponseDto;

/**
 * @summary Allow the user to login
 */
export const useAuthB2CLogin = <TError = BadRequestResponseDto, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authB2CLogin>>,
    TError,
    { data: LoginDto },
    TContext
  >;
}): UseMutationResult<Awaited<ReturnType<typeof authB2CLogin>>, TError, { data: LoginDto }, TContext> => {
  const mutationOptions = getAuthB2CLoginMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Allow to verify the email, unprotected route
 */
export const authB2CVerifyEmail = (verifyMailDto: VerifyMailDto, signal?: AbortSignal) => {
  return customInstance<VerifyEmailResponseDto>({
    url: `/auth-b2c/verify-mail`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: verifyMailDto,
    signal,
  });
};

export const getAuthB2CVerifyEmailMutationOptions = <
  TError = BadRequestResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authB2CVerifyEmail>>,
    TError,
    { data: VerifyMailDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authB2CVerifyEmail>>,
  TError,
  { data: VerifyMailDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authB2CVerifyEmail>>,
    { data: VerifyMailDto }
  > = props => {
    const { data } = props ?? {};

    return authB2CVerifyEmail(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthB2CVerifyEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof authB2CVerifyEmail>>
>;
export type AuthB2CVerifyEmailMutationBody = VerifyMailDto;
export type AuthB2CVerifyEmailMutationError = BadRequestResponseDto;

/**
 * @summary Allow to verify the email, unprotected route
 */
export const useAuthB2CVerifyEmail = <TError = BadRequestResponseDto, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authB2CVerifyEmail>>,
    TError,
    { data: VerifyMailDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authB2CVerifyEmail>>,
  TError,
  { data: VerifyMailDto },
  TContext
> => {
  const mutationOptions = getAuthB2CVerifyEmailMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Verify the email code
 */
export const authB2CVerifyEmailCode = (verifyEmailCodeDto: VerifyEmailCodeDto, signal?: AbortSignal) => {
  return customInstance<VerifyEmailResponseDto>({
    url: `/auth-b2c/verify-email-code`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: verifyEmailCodeDto,
    signal,
  });
};

export const getAuthB2CVerifyEmailCodeMutationOptions = <
  TError = BadRequestResponseDto | UnauthorizedResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authB2CVerifyEmailCode>>,
    TError,
    { data: VerifyEmailCodeDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authB2CVerifyEmailCode>>,
  TError,
  { data: VerifyEmailCodeDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authB2CVerifyEmailCode>>,
    { data: VerifyEmailCodeDto }
  > = props => {
    const { data } = props ?? {};

    return authB2CVerifyEmailCode(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthB2CVerifyEmailCodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof authB2CVerifyEmailCode>>
>;
export type AuthB2CVerifyEmailCodeMutationBody = VerifyEmailCodeDto;
export type AuthB2CVerifyEmailCodeMutationError = BadRequestResponseDto | UnauthorizedResponseDto;

/**
 * @summary Verify the email code
 */
export const useAuthB2CVerifyEmailCode = <
  TError = BadRequestResponseDto | UnauthorizedResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authB2CVerifyEmailCode>>,
    TError,
    { data: VerifyEmailCodeDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authB2CVerifyEmailCode>>,
  TError,
  { data: VerifyEmailCodeDto },
  TContext
> => {
  const mutationOptions = getAuthB2CVerifyEmailCodeMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Resend the verification code
 */
export const authB2CResendVerificationCode = (signal?: AbortSignal) => {
  return customInstance<SuccessTypeDto>({ url: `/auth-b2c/resend-verification-code`, method: 'POST', signal });
};

export const getAuthB2CResendVerificationCodeMutationOptions = <
  TError = BadRequestResponseDto | UnauthorizedResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authB2CResendVerificationCode>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof authB2CResendVerificationCode>>, TError, void, TContext> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authB2CResendVerificationCode>>,
    void
  > = () => {
    return authB2CResendVerificationCode();
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthB2CResendVerificationCodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof authB2CResendVerificationCode>>
>;

export type AuthB2CResendVerificationCodeMutationError = BadRequestResponseDto | UnauthorizedResponseDto;

/**
 * @summary Resend the verification code
 */
export const useAuthB2CResendVerificationCode = <
  TError = BadRequestResponseDto | UnauthorizedResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authB2CResendVerificationCode>>,
    TError,
    void,
    TContext
  >;
}): UseMutationResult<Awaited<ReturnType<typeof authB2CResendVerificationCode>>, TError, void, TContext> => {
  const mutationOptions = getAuthB2CResendVerificationCodeMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Refresh access token using refresh token
 */
export const authB2CRefreshToken = (refreshTokenDto: RefreshTokenDto, signal?: AbortSignal) => {
  return customInstance<RefreshTokenResponseDto>({
    url: `/auth-b2c/refresh-token`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: refreshTokenDto,
    signal,
  });
};

export const getAuthB2CRefreshTokenMutationOptions = <
  TError = BadRequestResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authB2CRefreshToken>>,
    TError,
    { data: RefreshTokenDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authB2CRefreshToken>>,
  TError,
  { data: RefreshTokenDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authB2CRefreshToken>>,
    { data: RefreshTokenDto }
  > = props => {
    const { data } = props ?? {};

    return authB2CRefreshToken(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthB2CRefreshTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof authB2CRefreshToken>>
>;
export type AuthB2CRefreshTokenMutationBody = RefreshTokenDto;
export type AuthB2CRefreshTokenMutationError = BadRequestResponseDto;

/**
 * @summary Refresh access token using refresh token
 */
export const useAuthB2CRefreshToken = <TError = BadRequestResponseDto, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authB2CRefreshToken>>,
    TError,
    { data: RefreshTokenDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authB2CRefreshToken>>,
  TError,
  { data: RefreshTokenDto },
  TContext
> => {
  const mutationOptions = getAuthB2CRefreshTokenMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Logout user from current device
 */
export const authB2CLogout = (signal?: AbortSignal) => {
  return customInstance<LogoutResponseDto>({ url: `/auth-b2c/logout`, method: 'POST', signal });
};

export const getAuthB2CLogoutMutationOptions = <
  TError = UnauthorizedResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof authB2CLogout>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof authB2CLogout>>, TError, void, TContext> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof authB2CLogout>>, void> = () => {
    return authB2CLogout();
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthB2CLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof authB2CLogout>>>;

export type AuthB2CLogoutMutationError = UnauthorizedResponseDto;

/**
 * @summary Logout user from current device
 */
export const useAuthB2CLogout = <TError = UnauthorizedResponseDto, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof authB2CLogout>>, TError, void, TContext>;
}): UseMutationResult<Awaited<ReturnType<typeof authB2CLogout>>, TError, void, TContext> => {
  const mutationOptions = getAuthB2CLogoutMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Logout user from all devices
 */
export const authB2CLogoutAllDevices = (signal?: AbortSignal) => {
  return customInstance<LogoutResponseDto>({ url: `/auth-b2c/logout-all-devices`, method: 'POST', signal });
};

export const getAuthB2CLogoutAllDevicesMutationOptions = <
  TError = UnauthorizedResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof authB2CLogoutAllDevices>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof authB2CLogoutAllDevices>>, TError, void, TContext> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof authB2CLogoutAllDevices>>, void> = () => {
    return authB2CLogoutAllDevices();
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthB2CLogoutAllDevicesMutationResult = NonNullable<
  Awaited<ReturnType<typeof authB2CLogoutAllDevices>>
>;

export type AuthB2CLogoutAllDevicesMutationError = UnauthorizedResponseDto;

/**
 * @summary Logout user from all devices
 */
export const useAuthB2CLogoutAllDevices = <TError = UnauthorizedResponseDto, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof authB2CLogoutAllDevices>>, TError, void, TContext>;
}): UseMutationResult<Awaited<ReturnType<typeof authB2CLogoutAllDevices>>, TError, void, TContext> => {
  const mutationOptions = getAuthB2CLogoutAllDevicesMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Generate an access token from a verification code
 */
export const authB2CGenerateAccessTokenFromCode = (
  generateAccessTokenFromCodeDto: GenerateAccessTokenFromCodeDto,
  signal?: AbortSignal,
) => {
  return customInstance<AuthB2CGenerateAccessTokenFromCode200>({
    url: `/auth-b2c/generate-access-token-from-code`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: generateAccessTokenFromCodeDto,
    signal,
  });
};

export const getAuthB2CGenerateAccessTokenFromCodeMutationOptions = <
  TError = BadRequestResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authB2CGenerateAccessTokenFromCode>>,
    TError,
    { data: GenerateAccessTokenFromCodeDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authB2CGenerateAccessTokenFromCode>>,
  TError,
  { data: GenerateAccessTokenFromCodeDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authB2CGenerateAccessTokenFromCode>>,
    { data: GenerateAccessTokenFromCodeDto }
  > = props => {
    const { data } = props ?? {};

    return authB2CGenerateAccessTokenFromCode(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthB2CGenerateAccessTokenFromCodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof authB2CGenerateAccessTokenFromCode>>
>;
export type AuthB2CGenerateAccessTokenFromCodeMutationBody = GenerateAccessTokenFromCodeDto;
export type AuthB2CGenerateAccessTokenFromCodeMutationError = BadRequestResponseDto;

/**
 * @summary Generate an access token from a verification code
 */
export const useAuthB2CGenerateAccessTokenFromCode = <
  TError = BadRequestResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authB2CGenerateAccessTokenFromCode>>,
    TError,
    { data: GenerateAccessTokenFromCodeDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authB2CGenerateAccessTokenFromCode>>,
  TError,
  { data: GenerateAccessTokenFromCodeDto },
  TContext
> => {
  const mutationOptions = getAuthB2CGenerateAccessTokenFromCodeMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Verify the validity of the token & the user account
 */
export const authB2CVerifyToken = (signal?: AbortSignal) => {
  return customInstance<VerifyTokenResponseDto>({ url: `/auth-b2c/verify`, method: 'GET', signal });
};

export const getAuthB2CVerifyTokenQueryKey = () => {
  return [`/auth-b2c/verify`] as const;
};

export const getAuthB2CVerifyTokenQueryOptions = <
  TData = Awaited<ReturnType<typeof authB2CVerifyToken>>,
  TError = BadRequestResponseDto | UnauthorizedResponseDto,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authB2CVerifyToken>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthB2CVerifyTokenQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authB2CVerifyToken>>> = ({ signal }) =>
    authB2CVerifyToken(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authB2CVerifyToken>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type AuthB2CVerifyTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof authB2CVerifyToken>>
>;
export type AuthB2CVerifyTokenQueryError = BadRequestResponseDto | UnauthorizedResponseDto;

export function useAuthB2CVerifyToken<
  TData = Awaited<ReturnType<typeof authB2CVerifyToken>>,
  TError = BadRequestResponseDto | UnauthorizedResponseDto,
>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof authB2CVerifyToken>>, TError, TData>> &
    Pick<
      DefinedInitialDataOptions<Awaited<ReturnType<typeof authB2CVerifyToken>>, TError, TData>,
      'initialData'
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthB2CVerifyToken<
  TData = Awaited<ReturnType<typeof authB2CVerifyToken>>,
  TError = BadRequestResponseDto | UnauthorizedResponseDto,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authB2CVerifyToken>>, TError, TData>> &
    Pick<
      UndefinedInitialDataOptions<Awaited<ReturnType<typeof authB2CVerifyToken>>, TError, TData>,
      'initialData'
    >;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthB2CVerifyToken<
  TData = Awaited<ReturnType<typeof authB2CVerifyToken>>,
  TError = BadRequestResponseDto | UnauthorizedResponseDto,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authB2CVerifyToken>>, TError, TData>>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Verify the validity of the token & the user account
 */

export function useAuthB2CVerifyToken<
  TData = Awaited<ReturnType<typeof authB2CVerifyToken>>,
  TError = BadRequestResponseDto | UnauthorizedResponseDto,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authB2CVerifyToken>>, TError, TData>>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getAuthB2CVerifyTokenQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const authB2CGoogleCallback = (signal?: AbortSignal) => {
  return customInstance<AuthB2CGoogleCallback200>({
    url: `/auth-b2c/google/callback`,
    method: 'GET',
    signal,
  });
};

export const getAuthB2CGoogleCallbackQueryKey = () => {
  return [`/auth-b2c/google/callback`] as const;
};

export const getAuthB2CGoogleCallbackQueryOptions = <
  TData = Awaited<ReturnType<typeof authB2CGoogleCallback>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authB2CGoogleCallback>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthB2CGoogleCallbackQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authB2CGoogleCallback>>> = ({ signal }) =>
    authB2CGoogleCallback(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authB2CGoogleCallback>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type AuthB2CGoogleCallbackQueryResult = NonNullable<
  Awaited<ReturnType<typeof authB2CGoogleCallback>>
>;
export type AuthB2CGoogleCallbackQueryError = unknown;

export function useAuthB2CGoogleCallback<
  TData = Awaited<ReturnType<typeof authB2CGoogleCallback>>,
  TError = unknown,
>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof authB2CGoogleCallback>>, TError, TData>> &
    Pick<
      DefinedInitialDataOptions<Awaited<ReturnType<typeof authB2CGoogleCallback>>, TError, TData>,
      'initialData'
    >;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthB2CGoogleCallback<
  TData = Awaited<ReturnType<typeof authB2CGoogleCallback>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authB2CGoogleCallback>>, TError, TData>> &
    Pick<
      UndefinedInitialDataOptions<Awaited<ReturnType<typeof authB2CGoogleCallback>>, TError, TData>,
      'initialData'
    >;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAuthB2CGoogleCallback<
  TData = Awaited<ReturnType<typeof authB2CGoogleCallback>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authB2CGoogleCallback>>, TError, TData>>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useAuthB2CGoogleCallback<
  TData = Awaited<ReturnType<typeof authB2CGoogleCallback>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof authB2CGoogleCallback>>, TError, TData>>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getAuthB2CGoogleCallbackQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary This method is used to reset the password of a user when he forgot his password
 */
export const authB2CPasswordReset = (forgottenPasswordDto: ForgottenPasswordDto) => {
  return customInstance<LoginResponseDto>({
    url: `/auth-b2c/password-reset`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: forgottenPasswordDto,
  });
};

export const getAuthB2CPasswordResetMutationOptions = <
  TError = BadRequestResponseDto | NotFoundResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authB2CPasswordReset>>,
    TError,
    { data: ForgottenPasswordDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authB2CPasswordReset>>,
  TError,
  { data: ForgottenPasswordDto },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authB2CPasswordReset>>,
    { data: ForgottenPasswordDto }
  > = props => {
    const { data } = props ?? {};

    return authB2CPasswordReset(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthB2CPasswordResetMutationResult = NonNullable<
  Awaited<ReturnType<typeof authB2CPasswordReset>>
>;
export type AuthB2CPasswordResetMutationBody = ForgottenPasswordDto;
export type AuthB2CPasswordResetMutationError = BadRequestResponseDto | NotFoundResponseDto;

/**
 * @summary This method is used to reset the password of a user when he forgot his password
 */
export const useAuthB2CPasswordReset = <
  TError = BadRequestResponseDto | NotFoundResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authB2CPasswordReset>>,
    TError,
    { data: ForgottenPasswordDto },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof authB2CPasswordReset>>,
  TError,
  { data: ForgottenPasswordDto },
  TContext
> => {
  const mutationOptions = getAuthB2CPasswordResetMutationOptions(options);

  return useMutation(mutationOptions);
};
